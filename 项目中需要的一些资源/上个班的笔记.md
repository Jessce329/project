### day7

#### 目标

> **单文件组件**
>
> **单文件组件中的路由配置**
>
> **element-ui框架的使用介绍**
>
> 开启项目：
>
> **使用脚手架搭建项目结构**



#### 单文件组件

> 这个内容会基于上一天的webpack的配置

步骤：

- **为什么需要单文件组件**

  - 之前创建组件的方式：Vue.component有什么缺点？
    - **全局定义 (Global definitions)** 强制要求每个 component 中的命名不得重复
    - **字符串模板 (String templates)** 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 `\`
    - **不支持 CSS (No CSS support)** 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏
    - **没有构建步骤 (No build step)** 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel
  - 一个组件应该包含三个部分：结构 + 样式 +功能

- 什么是单文件组件：

  - 文件扩展名为 `.vue` 的文件就是 单文件组件（single-file components(）
  - 一个单文件组件只描述一个组件
  - .vue为以上所有问题提供了解决方法，并且还可以使用 webpack 或 Browserify 等构建工具。

- **如何创建单文件组件**

  - 创建一个单文件组件

    - 添加一个文件扩展名为.vue的文件

    - 一个单文件组件应该包含三个部分：结构 (template)+ 样式(style) +功能(script)

    - 示例：

      ```vue
      <template>
          <!-- 一个组件只有一个根元素 -->
          <div class="hello">你好啊，世界！！！{{msg}}</div>
      </template>
      
      <script>
      // var Index = {template:''}
      // export导出当前组件实例
      // default:当前实例是默认实例，默认实例在这个文件被引入的时候会自动的导出
      // {} 就是当前的组件对象
      export default {
          // 不用写模板了，模板会自动的对应上面的template结构
          // 组件的data是一个函数
          data(){
              return {
                  msg:'hello world!!!'
              }
          }
      }
      </script>
      
      <style lang="less" scoped>
      // scoped：标记当前样式是局部作用域样式：说明这里面写的样式只有当前组件可以使用
      </style>
      ```

      

  - 理解单文件组件中的每个组成部分的作用

    - template:组件的结构
    - script:组件的功能和数据
    - style:组件样式

  - 这和之前创建组件的方式相比，到底解决了什么问题

- **如何在项目中运用单文件组件**

  > 我们最终的目的应该让这个组件能够在页面中进行展示

  - 能够完整的理解组件和html是如何进行关联

  - 到底如何来实现 这种关联

    - 在app.js中进行操作

    - 引入vue组件

    - 知道在html页面中哪个结构用于展示这个组件

    - 如何实现关联

      ```js
      // 1.引入vue
      import Vue from 'vue'
      // 2.引入你想展示的组件
      import Hello from '../components/HelloWorld.vue'
      
      new Vue({
          el:'#app',
          // 在Vue中有一个内置的render函数，它可以实现渲染
          // 函数有一个参数，这个参数是一个真正能够进行渲染的函数，我们所需要做的就是将这个渲染的结构返回
          render:(fn) => {
              // fn会渲染指定的组件内容，并将渲染的结果返回
              return fn(Hello)
          }
      })
      ```

  -  现在我们的Webpack配置不足以支持对vue文件的解析转换，所以我们对webpack进行新的配置，让其能够支持vue文件类型的打包转换

    ![10-vue文件报错信息](media\10-vue文件报错信息.png)

  - 添加webpack对vue文件的支持

    - 搜索：webpack支持vue

    - 下载:npm install -D vue-loader vue-template-compiler

    - 配置

      ```js
      const VueLoaderPlugin = require('vue-loader/lib/plugin')
      
      {
          test: /\.vue$/,
      	loader: 'vue-loader'
      }
      
      // 请确保引入这个插件！
      new VueLoaderPlugin()
      ```

      

#### 单文件组件中的路由配置

- 如何能够在项目中使用vue-router

  - 下载：npm install vue-router
  - 引入：import VueRouter from 'vue-router'
  - 创建 路由对象
  - 注入：router

- 如何添加路由配置--回顾

- **理解什么是根组件**

  - 就是在Vue实例中指定的首次进行渲染的组件

  - 后期所有的组件展示都是在这个根组件中进行展示的，所以这个组件中如果添加内容，只能是所有组件的公共部分

  - 一般情况下，这个组件中就只是添加一个router-view

    ```html
    <template>
        <div class="app">
            <router-link to='/index'>首页</router-link>
            <router-link to='/hello'>你好</router-link>
            <router-view></router-view>
        </div>
    </template>
    ```

    

#### element-ui框架的使用介绍

- 下载安装：npm i element-ui -S

- 引入

  ```js
  import ElementUI from 'element-ui';
  import 'element-ui/lib/theme-chalk/index.css';
  
  // 所有模板的使用都需要use
  Vue.use(ElementUI)
  ```

- 使用--说来话长





#### 项目创建

> 基于vue-cli + vue + VueRouter+wabpack+element-ui
>
> 使用脚 手架搭建项目架构：可以让我们不用再去发很多时间和精力关注webpack如何来实现打包构建，而是将精力放到项目业务处理上

- 脚 手架的使用

  - 下载安装：npm install -g @vue/cli

  - 全局安装在任何位置都能使用

  - 在你想要的目录 下运行脚手架：vue create 项目名称

  - 创建一个项目：vue create heima_manager

    ![11-脚手架创建项目](media\11-脚手架创建项目.png)

    ![12-手动配置](media\12-手动配置.png)

    ![13-选项选择](media\13-选项选择.png)

    ![14-预处理器选择](media\14-预处理器选择.png)

    ![15-eslint](media\15-eslint.png)

    ![16-lintonsave](media\16-lintonsave.png)

    ![17-配置的保存位置](media\17-配置的保存位置.png)

    ![18-你随意](media\18-你随意.png)

- 运行项目：切换到当前项目目录下，运行npm run serve



#### 添加git管理(用了码云)

- 有码云帐号

- 创建一个新的仓库

- 在你的项目目录下，打开git bash

- 注意：先pull,再push

- pull的时候的常见错误：

  - 不能合并没有任何关联的历史记录

    ![20-git-pull-error](media\20-git-pull-error.png)

  - 解决：在最后添加命令：--allow-unraleted-histories

    ![21-pull-success](media\21-pull-success.png)

  - pull的时候有可能造成文件冲突：都有README.md文件

    ![22-conflict](media\22-conflict.png)

  - 解决冲突：

    ![23-conflict-deal](media\23-conflict-deal.png)





#### 修改项目结构

- 删除不需要的文件或代码

  - 删除App.vue中的模板代码
  - 并且删除HelloWrold.vue

- 添加我们需要的资源或者文件

  - 在App.vue中添加模板代码：router-view

  - 添加Login.vue

  - 添加路由配置

    - 下载 + 安装

    - 创建路由对象

    - 配置路由

    - 暴露路由成员

      ```js
      import Vue from 'vue'
      import VueRouter from 'vue-router'
      
      // 引入路由所对应的组件
      // @:src  相当于Src目录
      import Login from '@/views/Login.vue'
      
      Vue.use(VueRouter)
      
      // 创建路由对象
      var router = new VueRouter({
        routes: [
          {
            name: 'login',
            path: '/login',
            component: Login
          }
        ]
      })
      
      export default router
      ```

      

  - 添加路由注入

    ```js
    import router from '@/router/router.js'
    
    new Vue({
      // 注入
      router,
      render: h => h(App)
    }).$mount('#app')
    ```

    

#### 项目中使用element-ui

- 下载安装：npm i element-ui
- 引入
- 使用



#### 使用element-ui来实现登陆界面

- 找到对应的组件》form表单》表单验证

- 详细说明第一个组件--表单

  ```html
  <el-form
        :model="ruleForm" // 当前表单所绑定的数据对象，以后每个表单元素就绑定这个对象中的某个属性,这里面的属性值一般都会参照接口文档进行定义，以方便后期的参数传递
        :rules="rules" // 表单元素 验证规则，这个规则和表单元素的prop属性对应
        ref="ruleForm" // 表单标识
        label-width="100px"
        class="demo-ruleForm"
      >
  ```

  - 删除不要的结构

  - 删除不要的属性：删除label

  - rules定义在data函数中

    - 验证规则是一个对象，里面的每个规则对应着表单元素中的prop属性的名称

      ```js
      rules: {
              // 每个名字对应着一个规则
              username: [
                // required：必须的
                // message：不满足规则时的提示信息
                // trigger：什么时候触发：blur指失去焦点时触发
                { required: true, message: '请输入用户名', trigger: 'blur' }
              ],
              password: [
                { required: true, message: '请输入密码', trigger: 'blur' },
                { min: 6, max: 16, message: '密码必须在6~16位之间', trigger: 'blur' }
              ]
            }
      ```

      

- 如何实现表单元素的用户输入提示:添加验证规则

  ```html
  <el-form :model="loginForm" :rules="rules" ref="loginForm" class="demo-ruleForm">
          <el-form-item prop="username">
            <el-input
              v-model="loginForm.username"
              prefix-icon="myicon myicon-user"
              placeholder="请输入用户名"
              clearable
            ></el-input>
          </el-form-item>
          <el-form-item prop="password">
            <el-input
              type="password"
              v-model="loginForm.password"
              prefix-icon="myicon myicon-key"
              placeholder="请输入密码"
              clearable
              @keyup.enter.native='loginsubmit'
            ></el-input>
          </el-form-item>
          <el-form-item>
            <el-button type="primary" class="login-btn" @click="loginsubmit">登陆</el-button>
          </el-form-item>
        </el-form>
  ```

  

- 添加自定义样式

  - 引入我提供的自定义样式文件

- 如果添加文本框的图标：参考input输入框来添加图标

- 如何验证用户数据实现提交的阻止和允许

  - 我们希望在单击登陆的时候再次验证用户数据，如果数据输入不合法，则给出提示，并且阻止本次请求

  - 再次验证的标准就是之前的rules

    ```js
    loginsubmit () {
          // 再次实现用户数据的验证
          //   可以调用当前表单的validate函数，当验证完毕的时候，会调用这个函数中的回调函数,它有一个valid的参数
          // 这个参数就是用来标记当前验证是否通过，如果为true,则通过，否则不通过
          this.$refs.loginForm.validate(valid => {
            if (valid) {
              console.log('ok')
            } else {
              console.log('no')
              //   一定要return false,否则不能真正的阻止
              return false
            }
          })
        }
    ```

    

- 显示用户提示

  - 找到合适的用户提示：消息提示

    - type:success | warning | info | error
    - this.$message.success('')
    - this.$message({})

  - 如何添加用户提示

    ```js
    this.$refs.loginForm.validate(valid => {
            if (valid) {
              console.log('ok')
            } else {
            //   this.$message.error('数据输入错误，请重新输入')
              this.$message({
                type: 'error',
                message: '数据输入错误，请重新输入'
              })
              //   一定要return false,否则不能真正的阻止
              return false
            }
          })
    ```

    

- 如何实现按下enter实现登陆

  ```html
  <el-form-item prop="password">
      <el-input
                type="password"
                v-model="loginForm.password"
                prefix-icon="myicon myicon-key"
                placeholder="请输入密码"
                clearable
                @keyup.enter.native='loginsubmit'
  	></el-input>
  </el-form-item>
  ```



#### 实现登陆业务处理

- 分析接口文档 ，理解接口文档的需要

  - url:login
  - type:'post',
  - data:{username:'',password:''}

- 实现接口方法

  - 下载+引入 axios

  - 添加接口方法

    ```js
    // 专门处理users用户管理
    
    // 引入
    import axios from 'axios'
    
    // 设置基准路径
    axios.defaults.baseURL = 'http://localhost:8888/api/private/v1/'
    
    // 实现用户登陆
    export const login = (data) => {
      return axios({
        method: 'post',
        url: 'login',
        data
      })
    }
    ```

    

- 在组件中需要做什么

  - 准备参数数据

  - 引入接口方法

    ```js
    // 在script中进行模块方法的引入
    import { login } from '@/api/user_api.js'
    ```

    

  - 调用接口方法

  - 接收 返回值

  - 进行用户提示或者跳转操作

    ```js
    loginsubmit () {
          // 再次实现用户数据的验证
          //   可以调用当前表单的validate函数，当验证完毕的时候，会调用这个函数中的回调函数,它有一个valid的参数
          // 这个参数就是用来标记当前验证是否通过，如果为true,则通过，否则不通过
          this.$refs.loginForm.validate(valid => {
            if (valid) {
            //   调用接口方法实现用户登陆
              login(this.loginForm)
                .then(res => {
                  console.log(res)
                  if (res.data.meta.status === 200) {
                    //   跳转
                  } else {
                    this.$message({
                      type: 'warning',
                      message: res.data.meta.msg
                    })
                  }
                })
                .catch(err => {
                  console.log(err)
                })
            } else {
            //   this.$message.error('数据输入错误，请重新输入')
              this.$message({
                type: 'error',
                message: '数据输入错误，请重新输入'
              })
              //   一定要return false,否则不能真正的阻止
              return false
            }
          })
        }
    ```

    

#### 实现登陆之后的路由跳转

- 添加一个"首页"单文件组件

  ```js
  <template>
      <div class="home">home</div>
  </template>
  <script>
  export default {
  
  }
  </script>
  <style lang="less" scoped>
  
  </style>
  
  ```

  

- 为这个首页添加路由配置

  ```js
  {
        name: 'home',
        path: '/home',
        component: Home
      }
  ```

  

- 使用this.$router来实现路由跳转

  ```js
  if (res.data.meta.status === 200) {
      //   跳转
      this.$router.push({ name: 'home' })
  }
  ```





#### Token介绍

> 可以实现状态保持
>
> 相比于cookie和session有什么优势
>
> 1.cookie和session基于浏览器
>
> 2.token不用基于浏览器，在任何的平台都能使用
>
> 它是为用户生成一个唯一的令牌--标识，它可以唯一的标识某个用户
>
> 原理:
>
> ​	1.客户端向服务喊叫发送请求，成功之后，服务器生成唯一的token,并返回到客户端
>
> ​	2.客户端后面的每一次请求都会手动的将这个值传递给服务器
>
> ​	3.服务器接收token,进行校验，确定操作的权限，并返回结果

- 我们要实现的业务是这样的
  - 登陆成功之后，先存储token值：localStorage
  - 在进行除了/login之外的路由跳转的时候，需要先获取token值，判断是否有token数据，如果有则进行处理
  - 将token数据传递给服务器，实现某个请求操作



#### Vuex

> Vuex是一个针对Vue.js开发的状态管理模式。说简单点儿就是一个工具，可以管理（修改或设置）所有组件用到的数据，而不需要借助之前的event bus或者props在组件间传值
>
> 大型单页应用程序，存在多组件共享数据的时候，需要用到

- vuex说明
  - 整个vuex的核心是一个Store,里面包含有state,mutaions,actions,getters
  - state是数据存储对象，我们需要存储的数据都可以存储在state中
  - mutations中存储操作State中数据的方法，我们可以直接通过commit进行调用，但是这种调用方式是同步方式--不推荐
  - actions:存储了触发mutations中的函数的方法，通过dispatch可以调用actions中的方法，它是的异步调用方式

![1562581381597](media\29-vuex)

- 使用vuex:

  - 下载：npm install vuex -S

  - 定义一个vuex模块

    ```js
    import Vue from 'vue'
    import Vuex from 'vuex'
    
    Vue.use(Vuex)
    const state = {}
    const mutations = {}
    const actions = {}
    const getters = {}
    export default new Vuex.Store({
      state,
      getters,
      actions,
      mutations
    })
    
    ```

  - 在main.js注入

    ```js
    // main.js
    import store from './store'
    
    new Vue({
      el: '#app',
      store,
      render: h => h(Counter)
    })
    ```

  - 实现Home组件显示登陆名称

    ```js
    import Vue from 'vue'
    import Vuex from 'vuex'
    
    Vue.use(Vuex)
    const state = {
      currentUerName: ''
    }
    const mutations = {
      setUserName (state, value) {
        state.currentUerName = value
      }
    }
    const actions = {
      setUserNameAction: ({ commit }, value) => {
        commit('setUserName', value)
      }
    }
    const getters = {
      getUserName (state) {
        return state.currentUerName
      }
    }
    export default new Vuex.Store({
      state,
      getters,
      actions,
      mutations
    })
    
    ```



#### 添加导航守卫

> Vue-Router中提供了导航守卫
>
> `vue-router` 提供的导航守卫主要用来通过跳转或取消的方式守卫导航

添加方式：添加前置导航守卫

```js
// 添加路由导航守卫
router.beforeEach((to, from, next) => {
  // 获取token
  var token = localStorage.getItem('heima_manager_token')
  // 如果没有token值，除非你去登陆，否则都应该重定向到登陆
  if (token || to.path === '/login') {
    // 如果有token,那么就next
    next()
  } else if (!token && to.path !== '/login') {
    next({ name: 'login' })
  }
})
```



#### 首页制作 

- 首页结构分析

  ![28-首页结构](media\28-首页结构.png)

- 添加样式

  ```cs
  .home {
    height: 100%;
    .el-menu-admin:not(.el-menu--collapse) {
      width: 200px;
      min-height: 400px;
    }
    .el-container {
      height: 100%;
    }
    .el-aside {
      background-color: #545c64;
    }
    .el-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #545c64;
    }
    .logo {
      height:60px;
      background: url(../assets/logo.png);
      background-size: cover;
      background-color: #fff;
    }
    .toggle-btn {
      padding: 0 15px;
      margin-left: -20px;
      font-size: 36px;
      color: white;
      cursor: pointer;
      line-height: 60px;
      &:hover {
        background-color: #4292CF;
      }
    }
    .system-title {
      font-size: 28px;
      color: white;
    }
    .welcome{
      color: white;
    }
  }
  ```

  

- **首页中需要使用到的组件--菜单**

  - 找到组件

  - 修改组件的结构

  - 设置组件的属性

    ```html
    <el-menu
              :router='true'
              :unique-opened='true'
              :default-active="'2-2'"
              class="el-menu-vertical-demo"
              background-color="#545c64"
              text-color="#fff"
              active-text-color="#ffd04b"
            >
              <el-submenu index="1">
                <template slot="title">
                  <i class="el-icon-location"></i>
                  <span>用户管理</span>
                </template>
                <el-menu-item index="1-1">
                  <template slot="title">
                    <i class="el-icon-location"></i>
                    <span>用户列表</span>
                  </template>
                </el-menu-item>
              </el-submenu>
              <el-submenu index="2">
                <template slot="title">
                  <i class="el-icon-location"></i>
                  <span>权限管理</span>
                </template>
                <el-menu-item index="/login">
                  <template slot="title">
                    <i class="el-icon-location"></i>
                    <span>角色列表</span>
                  </template>
                </el-menu-item>
                <el-menu-item index="2-2">
                  <template slot="title">
                    <i class="el-icon-location"></i>
                    <span>权限列表</span>
                  </template>
                </el-menu-item>
              </el-submenu>
            </el-menu>
    ```

  - 重点属性：

    - index:不能重复，否则会同时展开和合并
    - unique-opened：设置是否同一时间只展开一个菜单项
    - default-active：默认展开的菜单项，应该设置为子项的索引值
    - router：设置为true,index可以当成路由跳转来使用

- **首页中那些内容是变化的，应该如何实现这个变化**

  - 添加新 组件，实现嵌套路由， 让嵌套路由映射的组件在Home.vue的router-view中显示

  - 添加新组件

    ```html
    <template>
        <div class="wel">欢迎你</div>
    </template>
    <script>
    export default {
    
    }
    </script>
    <style lang="less" scoped>
    
    </style>
    
    ```

    

  - 设置嵌套路由

    ```js
    children: [
            {
              // 嵌套路由不用添加/，否则会破坏嵌套层次结构
              path: 'wel',
              component: Welcome
            }
          ]
    ```

    

  - 添加router-view

    ```ht
    <el-main>
    	<router-view></router-view>
    </el-main>
    ```

    

  - 添加路由重定向

    ```js
    {
          name: 'home',
          path: '/home',
          component: Home,
          redirect: { path: '/home/wel' },
          // 嵌套路由 》》 对应着Home组件中的router-view
          children: [
            {
              // 嵌套路由不用添加/，否则会破坏嵌套层次结构
              path: 'wel',
              component: Welcome
            }
          ]
        }
    ```

    





#### eslint插件

- 下载安装插件：eslint

- 添加插件配置

  ```js
  {
    "editor.fontSize": 20,
    "liveServer.settings.donotShowInfoMsg": true,
    "javascript.updateImportsOnFileMove.enabled": "always",
    "files.autoSave": "off",
    "eslint.validate": [
      "javascript",
      "javascriptreact",
      "vue-html",
      {
        "language": "vue",
        "autoFix": true
      },
      "html",
      "vue"
    ],
    "eslint.autoFixOnSave": true,
    // 需要 npm install -g eslint-plugin-vue
    "eslint.options": {
      "extensions": [
        ".js",
        ".vue"
      ]
    },
    "explorer.confirmDragAndDrop": false,
  }
  ```
  

  
- 重启vscode



#### 用户管理》用户列表

##### 添加组件，添加路由配置，实现导航跳转

- 添加组件:@/views/users/index.vue

  ```htm
  <template>
      <div class="users">用户列表</div>
  </template>
  <script>
  export default {
  
  }
  </script>
  <style lang="less" scoped>
  
  </style>
  ```

- 添加嵌套路由配置:@/router/router.js

  ```js
  {
      name: 'Users',
  	path: 'users',
  	component: Users
  }
  ```

- 设置导航菜单项的index属性:@/views/Home.vue

  ```html
  <el-menu-item index="/home/users">
  ```

  

##### 用户列表页面的制作 --静态

- 面包屑

- 搜索区域

- **表格数据展示区域**

  - 添加

    - 带边框的表格

    - 添加索引列

    - 自定义模板

      - 如果这一列提供用户交互，且需要完成用户交互所产生的业务，需要使用到当前行数据的时候，就应该使用自定义模板列
      - 自定义模板列必须使用template包含
      - 通过scope.row可以获取这一行数据源对象
      - 这里使用到的技术是**作用域插槽**

    - 添加文字提示：tooltip

      ```html
      <!-- 表格区域 -->
      <el-table :data="tableData" border style="width: 100%">
          <el-table-column type="index" width="50"></el-table-column>
          <el-table-column prop="date" label="日期" width="280"></el-table-column>
          <el-table-column prop="name" label="姓名" width="280"></el-table-column>
          <el-table-column prop="address" label="地址"></el-table-column>
          <el-table-column label="修改状态" width="100">
              <template slot-scope="scope">
                  <el-switch v-model="value2" active-color="#13ce66" inactive-color="#ff4949"></el-switch>
              </template>
          </el-table-column>
          <el-table-column label="操作">
              <template slot-scope="scope">
                  <el-tooltip class="item" effect="dark" content="编辑" placement="top">
                      <el-button type="primary" icon="el-icon-edit"></el-button>
                  </el-tooltip>
                  <el-tooltip class="item" effect="dark" content="分配角色" placement="top">
                      <el-button type="primary" icon="el-icon-share"></el-button>
                  </el-tooltip>
                  <el-tooltip class="item" effect="dark" content="删除" placement="top">
                      <el-button type="primary" icon="el-icon-delete"></el-button>
                  </el-tooltip>
              </template>
          </el-table-column>
      </el-table>
      ```

      

  - 常见属性：

    - data:表格的数据源
    - prop:列的属性，它用来设置这列展示数据源对象中的那个属性

- 分页组件



#####拦截器

> token数据并不会自动的传递，它不是浏览器的默认行，所以我们需要手动进行token值的传递，这也是我们在发送除了登陆之外的其它请求的时候出现的错误令牌：无效token的原因
>
> 我们当前不愿意在每个请求单独进行token传递的处理

> axios提供了拦截器：它可以拦截每一个请求，拦截之后你可以进行请求发送之前的处理
>
> 我们可以拦截器中进行token数据的传递
>
> 这样我们就只需要写一次，让每个请求都能使用到这个拦截器的设置

拦截器的使用：

- 如何添加拦截器

- 在拦截器中如何添加token值的设置

  ```js
  // 添加请求拦截器
  axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么?手动传递token
    // 1.获取token
    var token = localStorage.getItem('heima_manager_token')
    // 2.必须在请求头中使用 Authorization 字段提供 token 令牌
    config.headers['Authorization'] = token
    return config
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error)
  })
  ```

  



##### 数据动态展示

- 添加接口方法

  ```js
  // 获取用户列表数据
  export const getUserList = (pa) => {
    return axios({
      url: 'users',
      params: pa
    })
  }
  ```

- 在users.vue中引入接口方法

  ```js
  import {getUserList} from '@/api/user_api.js'
  ```

- 页面一加载就调用接口方法，获取返回数据

- 设置表格的数据源

  - 定义一个数据：userList,它是一个数组

    ```js
    getUserList({ query: this.query, pagenum: this.pagenum, pagesize: this.pagesize })
          .then(res => {
            console.log(res)
            this.userList = res.data.data.users
          })
          .catch(err => {
            console.log(err)
          })
    ```

- 设置列的prop属性

  - 将每一列的prop属性设置你想展示的数据属性名称

    ```html
    <el-table-column prop="username" label="姓名" width="280"></el-table-column>
    <el-table-column prop="email" label="邮箱" width="280"></el-table-column>
    <el-table-column prop="mobile" label="电话"></el-table-column>
    ```

    

##### 分页

- 找到分页组件

- 了解分页组件中的常见属性，了解每个属性的作用

  ```html
  <el-pagination
        @size-change="handleSizeChange" // 切换每页显示记录数时触发的函数，它有一个参数，参数就是你当前选择的数量
        @current-change="handleCurrentChange" // 切换当前页码时触发，这个处理函数也有一个参数，就是当前页码
        :current-page="currentPage4" // 当前页码
        :page-sizes="[100, 200, 300, 400]" // size下拉列表的选项值
        :page-size="100" // 默认每页所展示的记录数
        layout="total, sizes, prev, pager, next, jumper" // 分页组件的布局结构：总记录数，size切换下拉列表，上一页，页码，下一页，跳转页
        :total="400"> // 总记录数
      </el-pagination>
  ```

- 自己来定义分页组件中的属性值

  ```html
  <el-pagination
        @size-change="handleSizeChange"
        @current-change="handleCurrentChange"
        :current-page="pagenum"
        :page-sizes="[1, 2, 3, 4]"
        :page-size="pagesize"
        layout="total, sizes, prev, pager, next, jumper"
        :total="total">
      </el-pagination>
  ```

- 实现分页功能

  ```js
  // 切换size下拉列表时触发
      handleSizeChange (val) {
        //   重置 pagesize
        this.pagesize = val
        // 再镒拉取数据
        this.init()
      },
      // 切换当前页码
      handleCurrentChange (val) {
        //   将pagenum重置，再次发起数据请求
        this.pagenum = val
        this.init()
      }
  ```

#####用户筛选

- 添加用户关键字的双向绑定
- 添加文本框的enter事件
- 数据的获取方法之前已经完成

##### 用户添加

- 业务处理：写接口方法

  ```js
  // 添加用户数据
  export const addUser = (data) => {
    return axios({
      url: 'users',
      method: 'post',
      data
    })
  }
  ```

  

- 在vue组件中

  - 添加绑定事件--弹出对话框

  - 添加对话框

    - 重点属性：
      - :visible.sync：设置对话框显示或隐藏，如果值为true,则显示，否则隐藏

  - 弹出添加用户对话框：dialog

  - 添加表单及表单元素

    ```html
    <!-- 添加用户对话框 -->
    <el-dialog title="添加用户" :visible.sync="addDialogFormVisible">
        <el-form :model="addForm"  :label-width="'80px'" :rules='rules'>
            <el-form-item label="用户名" prop='username'>
                <el-input v-model="addForm.username" auto-complete="off"></el-input>
            </el-form-item>
            <el-form-item label="密码" prop='password'>
                <el-input v-model="addForm.password" auto-complete="off"></el-input>
            </el-form-item>
            <el-form-item label="邮箱" prop='email'>
                <el-input v-model="addForm.email" auto-complete="off"></el-input>
            </el-form-item>
            <el-form-item label="电话" prop='mobile'>
                <el-input v-model="addForm.mobile" auto-complete="off"></el-input>
            </el-form-item>
    
        </el-form>
        <div slot="footer" class="dialog-footer">
            <el-button @click="addDialogFormVisible = false">取 消</el-button>
            <el-button type="primary">确 定</el-button>
        </div>
    </el-dialog>
    ```

    

  - 添加表单元素的验证规则

    - 添加:rules绑定

    - 添加rules规则

    - 为表单元素设置prop属性

      ```js
      //   添加新增用户表单元素的验证规则
            rules: {
              username: [
                { required: true, message: '请填写用户名', trigger: 'blur' }
              ],
              password: [
                { required: true, message: '请填写密码', trigger: 'blur' }
              ],
              email: [
                // wuhu0723@126.com
              //   学习正则就是学习它的元字符
              // 1.占位符，说明这个位置需要填入满足要求的字符
              // \w:合法字符： 0-9 a-z A-Z _   \W：非法字符
              // \d:数字：0-9   \D:非数字
              // 2.修饰符：修饰前面的字符所出现的次数，前面的字符默认是指前面的一个字符，除非你使用()包含
              // +：修饰前面的字符出现1次或多次
              // ？：修饰前面的字符出现0次或1次
              // {n,m}:修饰前面的字符最少出现n次，最多出现m次
              // {n}:修饰前面的字符出现n次
              // {n,}修饰前面的字符最少出现n次，最多没有限制
                { required: true, message: '请填写email', trigger: 'blur', pattern: /\w+[@]\w+[.]\w{2,3}/ }
              ],
              mobile: [
                { required: true, message: '请填写手机号', trigger: 'blur' },
                { pattern: /^1[345678]\d{9}$/, message: '请填写正确的手机号(11位数字)', trigger: 'blur' }
              ]
            }
      ```

      

  - 调用接口方法实现用户的添加

    - 再次进行用户数据的验证
    - 调用方法
    - 实现页面的刷新

    ```js
     //   添加用户数据
    addUser () {
        // 1,再次实现数据的验证
        this.$refs.addForm.validate(valid => {
            if (valid) {
                addUser(this.addForm)
                    .then(res => {
                    if (res.data.meta.status === 201) {
                        //  让对话框隐藏
                        this.addDialogFormVisible = false
                        // 重置表单元素的数据
                        this.$refs.addForm.resetFields()
                        // 实现数据 刷新
                        this.init()
                    } else {
                        this.$message({
                            type: 'error',
                            message: res.data.meta.msg
                        })
                    }
                })
                    .catch(err => {
                    console.log(err)
                })
            } else {
                return false
            }
        })
        // 2 调用接口方法实现数据的添加
    }
    ```

    

##### 用户状态修改

- 设置合理的状态值--数据展示

  - 之前是所有switch都绑定到了同一个变量，所以值的状态修改同步

  - 我们需要绑定什么值才合理？

    ```js
    <template slot-scope="scope">
              <el-switch v-model="scope.row.mg_state" active-color="#13ce66" inactive-color="#ff4949"></el-switch>
    </template>
    ```

    

- 创建接口方法

  ```js
  // 修改用户状态
  export const updateUserState = (uid, type) => {
    return axios({
      url: `users/${uid}/state/${type}`,
      method: 'put'
    })
  }
  ```

  

- 在前台添加switch状态切换事件--@change

- 细节：注意默认参数

  - 如果没有手动添加参数，那么就传递默认参数：当前状态
  - 但是如果手动传递了参数，那么默认参数就不再进行传递

- 调用方法实现用户状态的切换

  ```js
  @change='changeUserState(scope.row.id,scope.row.mg_state)'
  -----------------------------
  // 修改用户状态
  changeUserState (id, type) {
      updateUserState(id, type)
          .then(res => {
          if (res.data.meta.status === 200) {
              this.$message({
                  type: 'success',
                  message: res.data.meta.msg
              })
          }
      })
  }
  ```

  



##### 用户删除

- 后台接口方法 ：@/api/user_api.js

  ```js
  // 根据用户id删除单个用户
  // 增加(post)    删除(delete)    修改(put)   查询(get)
  export const delUser = (id) => {
    return axios({
      method: 'delete',
      url: `users/${id}`
    })
  }
  ```

  

- vue组件中进行方法调用

- 数据刷新

  ```js
  // 删除单个用户
      deluserbyid (id) {
        // 给出删除用户提示
        this.$confirm('此操作将永久删除该用户, 是否继续?', '删除提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        })
          .then(() => {
            // 如果单击确定，就会执行.then
            // 真正执行删除操作
            delUser(id)
              .then(res => {
                if (res.data.meta.status === 200) {
                  this.$message({
                    type: 'success',
                    message: '删除成功'
                  })
                  // 判断本次删除之后，当前页还有没有数据，如果有数据，就保持页码为当前页，否则就到上一页
                  this.pagenum =
                    Math.ceil(this.total - 1 / this.pagesize) < this.pagenum
                      ? --this.pagenum
                      : this.pagenum
                  this.init()
                }
              })
              .catch(err1 => {
                this.$message({
                  type: 'error',
                  message: '删除失败'
                })
              })
          })
          .catch(() => {
            // 如果单击取消就会执行.catch
            this.$message({
              type: 'info',
              message: '已取消删除'
            })
          })
      }
  ```

  ##### 

##### 分配角色

- 分配角色接口方法的添加

- 添加分配角色对话框

- 添加一个接口方法获取所有角色数据

  ```js
  export const getAllRoleLlist = () => {
    return axios({
      url: 'roles'
    })
  }
  ```

  

- **设置对话框中的下拉列表**

  - 属性说明

    ```html
    // 后期用户进行选择，选择的:value值会和v-model的变量进行同步
    <el-select v-model="value4" clearable placeholder="请选择">
        <el-option
                   v-for="item in options" // 遍历数据源
                   :key="item.value" // v-for 配套的:key
                   :label="item.label" // 用于展示的属性--给你看的
                   :value="item.value" // 实际值--给你用的:id
    	></el-option>
    </el-select>
    ```

    ```js
    <el-select v-model="grantForm.rid" clearable placeholder="请选择">
                <el-option
                  v-for="item in roleList"
                  :key="item.id"
                  :label="item.roleName"
                  :value="item.id"
                ></el-option>
    </el-select>
    ```

- 实现下拉列表选项的默认选择：

  - 下拉列表的选项由v-model的数据决定(:value="item.value")

  - 意味着我们如果能够给v-model所绑定的数据赋值，那么它会就会找到这个值所对应的选项，将:label的数据进行展示

    ```js
    // 显示分配角色对话框
    showGrandDialog (row) {
        this.grantdialogFormVisible = true
        this.grantForm.username = row.username
        this.grantForm.id = row.id
        // 实现下拉列表选项的展示展示
        this.grantForm.rid = row.rid
    }
    ```

    

- 调用接口方法实现用户角色的分配

  ```js
   // 分配角色提交
  grantRoleSubmit () {
      // 判断是否选择了角色
      if (!this.grantForm.rid) {
          this.$message({
              type: 'warning',
              message: '请先选择角色'
          })
          return false
      }
      grantUserRole(this.grantForm.id, this.grantForm.rid)
          .then(res => {
          if (res.data.meta.status === 200) {
              this.$message({
                  type: 'warning',
                  message: res.data.meta.msg
              })
              this.grantdialogFormVisible = false
          }
      })
  }
  ```

  

##### 用户编辑

- 添加接口方法

  ```js
  // 编辑用户
  export const editUser = (data) => {
    return axios({
      url: `users/${data.id}`,
      method: 'put',
      data: { email: data.email, mobile: data.mobile }
    })
  }
  ```

  

- 添加编辑用户对话框

  ```js
  <el-dialog title="编辑用户" :visible.sync="editdialogFormVisible">
        <el-form :model="editForm" :label-width="'120px'" :rules='rules' ref='editForm'>
          <el-form-item label="用户名">
            <el-input v-model="editForm.username" auto-complete="off" disabled="" style='width:100px'></el-input>
          </el-form-item>
          <el-form-item label="邮箱" prop='email'>
            <el-input v-model="editForm.email" auto-complete="off"></el-input>
          </el-form-item>
          <el-form-item label="电话" prop='mobile'>
            <el-input v-model="editForm.mobile" auto-complete="off"></el-input>
          </el-form-item>
        </el-form>
        <div slot="footer" class="dialog-footer">
          <el-button @click="editdialogFormVisible = false">取 消</el-button>
          <el-button type="primary" @click='editUserSubmit'>确 定</el-button>
        </div>
  </el-dialog>
  ```

  

- 添加用户数据验证:复用之前添加用户的验证

- 加载用户默认数据--scope.row

  ```js
  // 显示编辑用户对话框
      showEditDialog (row) {
        this.editdialogFormVisible = true
        this.editForm.id = row.id
        this.editForm.username = row.username
        this.editForm.email = row.email
        this.editForm.mobile = row.mobile
      }
  ```

  

- 调用接口方法实现用户数据的编辑

  ```js
  // 编辑用户提交
      editUserSubmit () {
        this.$refs.editForm.validate(valid => {
          if (valid) {
            editUser(this.editForm).then(res => {
              if (res.data.meta.status === 200) {
                this.$message({
                  type: 'success',
                  message: res.data.meta.msg
                })
                this.editdialogFormVisible = false
                this.init()
              }
            })
          } else {
            this.$message({
              type: 'warning',
              message: '用户输入不合法'
            })
          }
        })
      }
  ```



#### 权限管理

##### 权限列表

- 添加接口方法

  - 添加一个文件：right_api.js

  - 封装一个axios模块：common.js，实现公共的：引入 + 设置基准路径 + 添加拦截器

    ```js
    // 引入
    import axios from 'axios'
    
    // 设置基准路径
    axios.defaults.baseURL = 'http://localhost:8888/api/private/v1/'
    
    // 添加请求拦截器
    axios.interceptors.request.use(function (config) {
      // 在发送请求之前做些什么?手动传递token
      // 1.获取token
      var token = localStorage.getItem('heima_manager_token')
      if (token) {
        // 2.必须在请求头中使用 Authorization 字段提供 token 令牌
        config.headers['Authorization'] = token
      }
      return config
    }, function (error) {
      // 对请求错误做些什么
      return Promise.reject(error)
    })
    // 导出axios对象
    export default axios
    
    ```

    

  - 添加接口方法

    ```js
    // 获取所有权限数据
    export const getAllRightList = (type) => {
      return axios({
        url: `rights/${type}`
      })
    }
    ```

    

- vue组件中的操作

  - 添加组件

  - 添加路由配置

    ```js
    {
              name: 'Role',
              path: 'roles',
              component: Role
            },
            {
              name: 'Right',
              path: 'rights',
              component: Right
            }
    ```

  - 添加导航菜单的路由设置

    ```html
    <el-submenu index="2">
        <template slot="title">
            <i class="el-icon-location"></i>
            <span>权限管理</span>
        </template>
        <el-menu-item index="/home/roles">
            <template slot="title">
                <i class="el-icon-location"></i>
                <span>角色列表</span>
            </template>
        </el-menu-item>
        <el-menu-item index="/home/rights">
            <template slot="title">
                <i class="el-icon-location"></i>
                <span>权限列表</span>
            </template>
        </el-menu-item>
    </el-submenu>
    </el-menu>
    ```

    

  - 制作vue组件中的页面结构：

    - 面包屑
    - 表格

  - 操作

    - 获取所有权限数据

      ```js
      mounted () {
          getAllRightList('list')
            .then(res => {
              console.log(res)
              this.rightList = res.data.data
            })
        }
      ```

      

    - 添加过滤器

      - 之前通过Vue.filter来添加过滤器--全局过滤器

      - 在组件内部添加局部过滤器：

        ```js
        filters:{
            // 如果没有传递参数，就会默认传递管道符前面的数据
            // 如果传递了参数，也不会影响默认参数的传递
            过滤器名称：()=>{
                return ''
            }
        }
        ```

        ```js
        //   通过filters添加当前组件的局部过滤器
          filters: {
            levelFormat: (level) => {
              if (level === 0) {
                return '一级'
              } else if (level === 1) {
                return '二级'
              } else if (level === 2) {
                return '三级'
              }
            }
          }
        ```

      - 使用过滤器：使用管道符：  数据 | 过滤器

        - 添加自定义模板

        - 使用插值表达式

          ```html
          <el-table-column label="层级" width="100">
                  <template slot-scope="scope">{{scope.row.level | levelFormat}}</template>
          </el-table-column>
          ```

          

#####角色列表

> 今天的业务的关键在于数据结构，分析清楚数据结构才能有效的完成页面中的业务

- 添加组件中的表格结构

  - 索引列
  - 自定义模板
  - **展开行**

- 实现角色列表数据的动态展示

  - 添加接口方法--已经完成了
  - 调用接口方法获取数据，为表格数据源赋值
  - 分析数据结构

- **实现展开行数据显示**

  - 栅格系统

  - 数据嵌套对应着展示结构的嵌套

    ```html
    <el-table-column type="expand">
            <template slot-scope="scope">
              <el-row v-for="first in scope.row.children" :key="first.id" style='margin-bottom:10px;border-bottom:1px #ccc dashed'>
                <el-col :span="4">
                  <el-tag closable type="success">{{first.authName}}</el-tag>
                </el-col>
                <el-col :span="20">
                    <el-row v-for='second in first.children' :key='second.id' style='margin-bottom:6px'>
                        <el-col :span='4'>
                            <el-tag closable type="warning">{{second.authName}}</el-tag>
                        </el-col>
                        <el-col :span='20'>
                            <el-tag closable type="info" v-for='third in second.children' :key='third.id' style='margin-right:4px;margin-bottom:6px'>{{third.authName}}</el-tag>
                        </el-col>
                    </el-row>
                </el-col>
              </el-row>
              <el-row>
                  <el-col :span='24' v-show='scope.row.children.length === 0'> 没有任何的权限，请先去分配</el-col>
              </el-row>
            </template>
          </el-table-column>
    ```

    

- **实现展开行数据标签的删除功能**

  - 接口方法的添加：仔细接口文档 》 删除角色指定权限

    ```js
    // 删除指定角色的指定权限
    export const delRightByRoleId = (roleId, rightId) => {
      return axios({
        method: 'delete',
        url: `roles/${roleId}/rights/${rightId}`
      })
    }
    ```

  - vue组件中调用方法实现删除

  - **删除之后的数据刷新**

    - 不要直接刷新整个表格数据

    - 我们发现，删除操作返回的数据就是当前角色还剩余的权限数据，所以我们可以将这个数据重置当前展开行数据的数据源对象

    - 这一个角色的展开行数据源是：scope.row.children,它是一个数组

    - 而我们返回的数据中描述当前角色权限数据的结构也是一个数组

      ```js
      delRight (row, rightId) {
            delRightByRoleId(row.id, rightId)
              .then(res => {
                console.log(res)
                if (res.data.meta.status === 200) {
                  this.$message({
                    type: 'success',
                    message: res.data.meta.msg
                  })
                  // 重置当前展开行数据的数据源数组
                  row.children = res.data.data
                }
              })
          }
      ```

      

- 添加分配权限的对话框

- 添加对话框中的树形组件

  - 树形组件的常见属性

    ```js
    <el-tree
        :data="data2" // 树形组件的数据源
        show-checkbox // 显示复选框
        node-key="id" // 当前节点的标识属性，以id来唯一标识这个节点
        :default-expanded-keys="[2, 3]" // 默认需要展开的节点id数组，我们到时候默认展开所有节点
        :default-checked-keys="[5]" // 默认被选择中的节点id所组成的数组
        :props="defaultProps" // 节点配置，主要配置：显示的内容属性，下一级查询数组
    ></el-tree>
     defaultProps: {
         children: 'children', // 下一级会查询children
    	 label: 'label' // 当前节点所展示的属性名称
     }
    ```

- 实现我们自己的树形组件数据展示

  - 获取数据：传入参数：tree

  - **我们所需要的树形组件的设置**

    ```js
    <el-tree
        :data="rightList"
        show-checkbox
        node-key="id"
        :default-expand-all='true' // 默认展开所有节点
        :default-checked-keys="checkedArr" //后期需要去动态获取，因为不同的角色所拥有的权限可能不一样
        :props="defaultProps"
    ></el-tree>
    -----------------------
    defaultProps: {
    	children: 'children', // 用于查询下一级节点的属性名称--数组
    	label: 'authName' // 用于展示的属性名称
    }
    ```

    

- **实现树形组件中节点的默认选择**

  - 不同的角色所拥有的权限是不一样的

  - 所以我们得打开对话框之后再权限这个角色的权限去获取应该被选中的节点id数组

  - 我们只需要获取第三级权限所对应的id

  - 我们可以通过遍历获取这个角色所有三级权限所对应的id

    ```js
    // 获取这个角色所有对应的三级权限id
    // 每次遍历前将之前可能的权限id清空
    this.checkedArr.length = 0
    row.children.forEach((first, index) => {
        if (first.children && first.children.length > 0) {
            // 遍历二级权限
            first.children.forEach(second => {
                if (second.children && second.children.length > 0) {
                    // 遍历三级权限
                    second.children.forEach(third => {
                        this.checkedArr.push(third.id)
                    })
                }
            })
        }
    })
    ```

    

- **实现为角色分配权限** >角色授权

  - 分析接口方法，发现完成这个功能需要两个参数

    - roleId:当前角色id

    - rids:当前用户所选择所有权限id所组成的字符串，id之间以，分隔，如“1，2，3，4，5”

      ```js
      // 为角色分配权限
      export const grantRightForRole = (roleId, rids) => {
        return axios({
          url: `roles/${roleId}/rights`,
          method: 'post',
          data: { rids }
        })
      }
      ```

  - vue组件中的操作

    - 添加事件

    - 获取roleId

    - **获取树形组件中所有被选中的权限id**

      - 我们应该获取完整层次结构，因为如果只是存储三级权限，那么在进行数据展示或者数据删除的时候，不能找到某个权限的上一级或者下一级
      - getCheckedKeys:可以获取当前被选择的权限id的数组
        - 但是在没有选择所有子节点的时候，它无法获取这些权限的父级权限--不符合我们的需要
      - getCheckedNodes:
        - 它能获取到什么
        - 获取到的结果与我们的需要到底还要经过那些操作

    - 调用接口方法，实现权限分配的功能

    - 刷新

      ```js
      //   为角色授权
          grantRightSubmit () {
          //   var arr = this.$refs.mytree.getCheckedKeys()
            var arr = this.$refs.mytree.getCheckedNodes()
            //  [{id:109,pid:'107,102},{id:154,pid:'107,102}]
            console.log(arr)
            // 遍历，拼接
            var temp = []
            for (var i = 0; i < arr.length; i++) {
              temp.push(arr[i].id + ',' + arr[i].pid)
            }
            //   ['109,107,102', '154,107,102']
            console.log(temp)
            //   将temp转换为字符串
            var str = temp.join(',')
            //   '109,107,102,154,107,102'
            console.log(str)
            //   去重：只有数组可以去重
            var arr2 = str.split(',')
            //   [109,107,102, 154,107,102]
            console.log(arr2)
            //   new Set:数组去重 new Set:{109,107,102,154}
            var finalArr = [...new Set(arr2)]
            //   ...可以将对象的成员展开为一个一个值 [109,107,102,154]
            console.log(finalArr)
      
            grantRightForRole(this.roleId, finalArr.join(','))
              .then(res => {
                if (res.data.meta.status === 200) {
                  this.$message({
                    type: 'success',
                    message: res.data.meta.msg
                  })
                  this.grantdialogFormVisible = false
                  this.init()
                }
              })
          }
      ```

      

#### 添加角色

- 添加角色对话框

- 实现添加角色的功能

  - 添加接口方法

    ```js
    // 添加角色
    export const addrole = (data) => {
      return axios({
        url: `roles`,
        method: 'post',
        data: data
      })
    }
    ```

  - 调用接口方法实现角色的添加

  ```js
  // 添加角色
      addrole () {
        addrole(this.addform)
          .then(res => {
            console.log(res)
            if (res.data.meta.status === 201) {
              this.$message({
                type: 'success',
                messgae: res.data.meta.msg
              })
              this.adddialogFormVisible = false
              this.init()
            }
          })
      }
  ```

  

#### 左侧菜单项的动态生成

> 不同的角色能够实现的功能是不一样的，功能体现在左侧菜单的选项上。意味着如果没有某个功能，最好不要显示某个菜单项

- 实现接口方法

  ```js
  // 获取左侧菜单列表
  export const getLeftMenuList = () => {
    return axios({
      url: `menus`
    })
  }
  
  ```

  

- 在home页进行菜单项的动态生成

  ```js
  <el-submenu :index="first.id + ''" v-for='first in menuList' :key='first.id'>
      <template slot="title">
          <i class="el-icon-location"></i>
  <span>{{first.authName}}</span>
  </template>
  <el-menu-item :index="'/home/'+second.path" v-for='second in first.children' :key='second.id'>
      <template slot="title">
          <i class="el-icon-location"></i>
  <span>{{second.authName}}</span>
  </template>
  </el-menu-item>
  </el-submenu>
  ```

  

- 细节：拼接路由，路由名称不能随意，而是需要和后台返回的数据完全一致



#### 完成权限管理的演示

- 添加角色
- 为角色授权
- 添加用户
- 为用户指定角色
- 启用用户
- 使用当前新增用户登陆
- 观察左侧菜单项，验证操作的有效性



####商品列表

- 添加组件

  ```html
  <template>
      <div class="goods">
          <router-view></router-view>
      </div>
  </template>
  <script>
  export default {
  
  }
  </script>
  
  ```

  

- 添加嵌套路由

  ```js
  		{
            name: 'Goods',
            path: 'goods',
            component: Goods,
            redirect: { name: 'List' },
            children: [
              {
                name: 'List',
                path: 'lists',
                component: List
              },
              {
                name: 'Add',
                path: 'add',
                component: Add
              }
            ]
          }
  ```

  

- 嵌套路由对应着嵌套组件



###### 添加组件结构

######添加接口方法，获取数据

```js
// 获取所有商品列表数据
export const getAllGoodsList = (params) => {
  return axios({
    url: 'goods',
    params
  })
}
```

```js
mounted () {
    getAllGoodsList(this.goodsObj)
      .then(res => {
        console.log(res)
        this.goodsList = res.data.data.goods
      })
  }
```



######实现分页效果

- 分页组件的常用属性

  ```js
  <el-pagination
        @size-change="handleSizeChange" // 切换每页显示的记录数所触发的事件
        @current-change="handleCurrentChange" // 单击页码所触发的事件
        :current-page="currentPage4" //当前页码
        :page-sizes="[100, 200, 300, 400]" // 每页显示的记录数的设置数组
        :page-size="100" // 每页所显示的记录数
        layout="total, sizes, prev, pager, next, jumper" // 分页组件的组成部分
        :total="400"> // 总记录数
      </el-pagination>
  ```

  

- 我们所进行属性配置

  ```js
  <!-- 分页结构 -->
      <el-pagination
          style='background:#ddd;margin-top:15px'
        @size-change="handleSizeChange"
        @current-change="handleCurrentChange"
        :current-page="goodsObj.pagenum"
        :page-sizes="[10, 20, 30, 40]"
        :page-size="goodsObj.pagesize"
        layout="total, sizes, prev, pager, next, jumper"
        :total="total">
      </el-pagination>
  ```

  

- 实现分页功能

  - 单击页码

    ```js
    handleCurrentChange (val) {
          // val:就是用户当前所点击的页码
          //   单击某个页码，应该去获取这个页码对应页的数据
          this.goodsObj.pagenum = val
          this.init()
        }
    ```

    

  - 切换显示记录数

    ```js
     handleSizeChange (val) {
          // val就是用户当前所选择数量
          this.goodsObj.pagesize = val
          this.init()
        }
    ```

    

######实现新增商品的跳转

###### 新增商品单文件组件的内容添加

- 步骤条

- 标签页

- 实现步骤条和标签页的关联

  - 让步骤条和标签页绑定同一个属性

  - 在切换标签页的时候，修改当前属性值，以便影响步骤条的选项

  - 注意步骤条中的:active的数据类型中数值

    ```html
    <!-- 添加步骤条 -->
        <el-steps :active="activeName-0" finish-status="success">
          <el-step title="步骤 1"></el-step>
          <el-step title="步骤 2"></el-step>
          <el-step title="步骤 3"></el-step>
          <el-step title="步骤 4"></el-step>
          <el-step title="步骤 5"></el-step>
        </el-steps>
        <!-- 添加标签页 -->
        <el-tabs v-model="activeName" tab-position='left' style="margin-top:15px" @tab-click="handleClick">
          <el-tab-pane label="基本信息" name="0">基本信息</el-tab-pane>
          <el-tab-pane label="商品参数" name="1">商品参数</el-tab-pane>
          <el-tab-pane label="商品属性" name="2">商品属性</el-tab-pane>
          <el-tab-pane label="商品图片" name="3">商品图片</el-tab-pane>
          <el-tab-pane label="商品内容" name="4">商品内容</el-tab-pane>
        </el-tabs>
    ```

    

- 级联选择器

  - 找到级联选择器

  - 理解 级联选择哭喊 的常见属性

    - options:数据源
    - clearable：可清除
    - props：展示属性
      - value:背景的对应 实际值=--id
      - lebal:显示的标签文本
      - children:下一级

  - 我们的属性配置

    ```js
    <el-form-item label="商品分类">
    	<el-cascader :options="goodsCateList" :props="cascaderProps" clearable></el-cascader>
    </el-form-item>
    --------------------------
    cascaderProps: {
            checkStrictly: true,
            label: 'cat_name',
            value: 'cat_id',
            children: 'children'
          }
    ```

    

  - 如果获取我们想要的数据

    - 添加获取所有商品分类的接口方法

      ```js
      // 获取所有商品分类数据
      export const getCateList = (type) => {
        return axios({
          url: 'categories',
          params: { type }
        })
      }
      ```

      

    - 调用方法，生成动态数据

      ```js
      getCateList(3)
            .then(res => {
              console.log(res)
              if (res.data.meta.status === 200) {
                this.goodsCateList = res.data.data
              }
            })
      ```

      

    - 添加级联选择器的选项切换事件，获取id

      ```js
      getcate (value) {
            console.log(value)
            console.log('----------------------')
            //   获取双向绑定的数据
            console.log(this.addform.goods_cat)
          }
      ```

      

- 文件上传功能的实现：选择即上传

  - 找到文件组件

  - 理解和掌握它的属性和常见事件

    ```html
    <el-upload
               class="upload-demo" // 样式
               headers:{},
               action="http://localhost:8888/api/private/v1/upload" // 实现图片上传的服务器接口地址。它会自动的调用你所指定的接口来实现图片的上传功能
               :on-preview="handlePreview" //单击预览
               :on-remove="handleRemove" // 移除照片中触发事件
               :file-list="fileList2" // 当前所选择上传的文件列表，它是一个数组
               list-type="picture"  // 文件列表显示的风格--照片墙
               >
    ```

    

  - 实现文件上传的功能

    - 重点细节：文件上传组件内部封装了异步操作，意味着它并没有使用我们自己封装的axais,意味着也不会通过axios的拦截器，也就意味着我们在拦截器中设置的token传递压根没有效果

    - 这也就意味着我们在使用文件上传组件时，需要手动进行token值的传递

    - 之前在拦截器中，我们是通过请求头的方式进行token数据的传递

    - 现在也一样：我们需要在请求头设置Authorization，值为token

    - 我们面临两个问题：

      - 在文件上传组件中如何设置？headers:{Authorization:token}

      - 如何获取token数据---localStorage

        ```js
        <el-upload
                    class="upload-demo"
                    action="http://localhost:8888/api/private/v1/upload"
                    :on-remove="handleRemove"
                    :headers="gettoken()"
                    :file-list="fileList"
                    list-type="picture"
                  >
        -------------------------
        gettoken () {
              var token = localStorage.getItem('heima_manager_token')
              return { Authorization: token }
            }
        ```

        

  - 获取文件上传成功之后的返回值

    > 我们上传文件的最终的目的 是准备好添加商品时所需要的数据，意味着我们需要获取到文件上传之后服务器存储文件时的路径或文件名

    - 我们获取文件名应该在文件上传成功之后来获取

      ```js
      // 文件上传成功之后的钩子
          handleSuccess (response, file, fileList) {
            // 将当前成功上传的文件添加到数据对象中
            this.addform.pics.push({ pic: response.data.tmp_path })
          }
      ```

  - 移除文件

    - 不仅仅需要从列表中移除展示，而且还需要将数据从pics移除

    - 就要使用移除文件时的钩子函数

    - 在钩子函数中可以获取到当前被删除的文件名称，在pics查询到对应的文件对应进行删除

      ```js
      // 移除图片时触发
          handleRemove (file, fileList) {
            if (!file.response) {
              return
            }
            // 查询对应名称的文件对象进行删除
            for (var i = 0; i < this.addform.pics.length; i++) {
              if (this.addform.pics[i].pic === file.response.data.tmp_path) {
                this.addform.pics.splice(i, 1)
              }
            }
          }
      ```

      

  - 限制选择文件的类型:beforeUpload:

    ```js
    // 文件上传之前的钩子
        beforeUpload (file) {
          console.log(file)
          if (file.type.indexOf('image/') === -1) {
            this.$message({
              type: 'warning',
              message: '请选择图片格式的文件'
            })
            return false
          }
        }
    ```

    

- 富文本插件的使用

  - 我们使用什么：Vue-Quill-Editor

  - 下载：

  - 如何使用

    ```js
    import { quillEditor } from 'vue-quill-editor'
    import 'quill/dist/quill.core.css'
    import 'quill/dist/quill.snow.css'
    import 'quill/dist/quill.bubble.css'
    export default {
      components: {
        quillEditor
      }
        ----------------------------------
        <quill-editor
                v-model="addform.goods_introduce"
                ref="myQuillEditor"
                :options="editorOption"
                style='height:400px;border-bottom:1px solid #ccc'>
            </quill-editor>
    ```

    

- 实现商品数据的新增

  ```js
  // 添加商品
      addGoods () {
        addGoods(this.addform)
          .then(res => {
            console.log(res)
            if (res.data.meta.status === 201) {
              this.$router.push({ name: 'List' })
            }
          })
      }
  ```

  